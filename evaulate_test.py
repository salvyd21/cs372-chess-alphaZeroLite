# -*- coding: utf-8 -*-
"""Evaulate-test.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Jv2LvpUsemtJci9IbW690fmttSGdz7f2
"""

!git clone https://github.com/salvyd21/cs372-chess-alphaZeroLite.git

"""**Reasoning**:
I will inspect the repository structure by listing all Python files and reading the main entry point to identify the model definition.


"""

import os

# Define the root directory of the repository
repo_root = '/content/cs372-chess-alphaZeroLite'

print(f"Scanning directory: {repo_root}\n")

# Walk through the directory and list all .py files
python_files = []
for root, dirs, files in os.walk(repo_root):
    for file in files:
        if file.endswith(".py"):
            full_path = os.path.join(root, file)
            python_files.append(full_path)
            print(full_path)

print("\n--- Content of main.py ---\n")
# Read and print the content of main.py to check for imports
main_py_path = os.path.join(repo_root, 'main.py')
if os.path.exists(main_py_path):
    with open(main_py_path, 'r') as f:
        print(f.read())
else:
    print("main.py not found.")

"""**Reasoning**:
I have identified the model classes (`ChessGame` and `NNetWrapper`) from `main.py`. Now I will add the repository to the system path, import these classes, instantiate them, and load the weights from the specified path.


"""

import sys
import os
import torch

# Add the repository root to sys.path to allow imports from src
repo_root = '/content/cs372-chess-alphaZeroLite'
if repo_root not in sys.path:
    sys.path.append(repo_root)

# Import the necessary classes
# Based on main.py imports
try:
    from src.chess_engine.ChessGame import ChessGame
    from src.chess_nnet.NNetWrapper import NNetWrapper
    print("Classes imported successfully.")
except ImportError as e:
    print(f"Error importing classes: {e}")

# Define arguments similar to main.py
class Args:
    batch_size = 256
    epochs = 10
    num_workers = 4
    use_gpu = True
    device = "cuda" if torch.cuda.is_available() else "cpu"
    # Paths
    models_dir = "/content/cs372-chess-alphaZeroLite/models"

args = Args()
print(f"Using device: {args.device}")

# Instantiate the Game and the Neural Net Wrapper
game = ChessGame()
# Pass args if NNetWrapper accepts it (based on main.py eval_on_testset usage)
net_wrapper = NNetWrapper(game, args)

# Define the weights path
weights_path = os.path.join(args.models_dir, "supervised_best.pth")

# Check if weights exist
if os.path.exists(weights_path):
    print(f"Loading weights from {weights_path}...")
    # load_checkpoint typically expects folder and filename
    folder = os.path.dirname(weights_path)
    filename = os.path.basename(weights_path)
    try:
        net_wrapper.load_checkpoint(folder=folder, filename=filename)
        print("Weights loaded successfully.")
    except Exception as e:
        print(f"Error loading weights: {e}")
else:
    print(f"Weights file not found at {weights_path}. Please ensure the file exists or check the path.")
    # If weights are missing, we might proceed with an initialized model for sanity check demonstration,
    # but we should warn the user.

# Move to device explicitly if needed (NNetWrapper usually handles it but good to confirm)
net_wrapper.nnet.to(args.device)

print("Model instantiated and ready.")

"""# Task
Install the necessary libraries (including `python-chess`) using the file `"/content/cs372-chess-alphaZeroLite/requirements.txt"` to ensure the chess engine functions correctly. Then, import the `ChessGame` and `NNetWrapper` classes from the repository, instantiate the model, and load the weights from `"/content/cs372-chess-alphaZeroLite/models/supervised_best.pth"`. Finally, run a sanity check by predicting moves for a few sample board states to verify that the policy and value heads are working as expected, and summarize the model validation results.

## Install Dependencies

### Subtask:
Install the required libraries from `requirements.txt` and ensure `python-chess` is available.

**Reasoning**:
Install the project dependencies from requirements.txt and explicitly install python-chess to resolve the 'No module named chess' error.
"""

!pip install -r /content/cs372-chess-alphaZeroLite/requirements.txt
!pip install python-chess

"""**Reasoning**:
Now that dependencies are installed, I will import the necessary classes, instantiate the model, load the weights, and perform a sanity check by predicting on the initial board state.


"""

import sys
import os
import torch
import numpy as np

# Add the repository root to sys.path
repo_root = '/content/cs372-chess-alphaZeroLite'
if repo_root not in sys.path:
    sys.path.append(repo_root)

# Import the necessary classes
from src.chess_engine.ChessGame import ChessGame
from src.chess_nnet.NNetWrapper import NNetWrapper

# Define arguments
class Args:
    batch_size = 256
    epochs = 10
    num_workers = 4
    use_gpu = True
    device = "cuda" if torch.cuda.is_available() else "cpu"
    models_dir = "/content/cs372-chess-alphaZeroLite/models"

args = Args()
print(f"Using device: {args.device}")

# Instantiate the Game and the Neural Net Wrapper
game = ChessGame()
net_wrapper = NNetWrapper(game, args)

# Load weights
weights_path = os.path.join(args.models_dir, "supervised_best.pth")
if os.path.exists(weights_path):
    print(f"Loading weights from {weights_path}...")
    folder = os.path.dirname(weights_path)
    filename = os.path.basename(weights_path)
    try:
        net_wrapper.load_checkpoint(folder=folder, filename=filename)
        print("Weights loaded successfully.")
    except Exception as e:
        print(f"Error loading weights: {e}")
else:
    print(f"Weights file not found at {weights_path}.")

# Sanity Check: Predict on the initial board
print("\n--- Sanity Check ---")
board = game.getInitBoard()
policy, value = net_wrapper.predict(board)

print(f"Prediction on initial board:")
print(f"Value (Winning probability/Score): {value}")
print(f"Policy (Move probabilities) shape: {len(policy)}")
print(f"Top 5 moves (indices): {np.argsort(policy)[-5:][::-1]}")
print(f"Top 5 probabilities: {np.sort(policy)[-5:][::-1]}")

"""**Reasoning**:
The error `ModuleNotFoundError: No module named 'core'` occurs because the `NNetWrapper` module imports `core` directly, which is located inside the `src` directory. Adding the `src` directory to `sys.path` will allow Python to resolve the `core` module correctly.


"""

import sys
import os
import torch
import numpy as np

# Define paths
repo_root = '/content/cs372-chess-alphaZeroLite'
src_path = os.path.join(repo_root, 'src')

# Add the repository root and src directory to sys.path
if repo_root not in sys.path:
    sys.path.append(repo_root)
if src_path not in sys.path:
    sys.path.append(src_path)

# Import the necessary classes
# Note: NNetWrapper inside src/chess_nnet imports 'core', which works now that 'src' is in path
from src.chess_engine.ChessGame import ChessGame
from src.chess_nnet.NNetWrapper import NNetWrapper

# Define arguments
class Args:
    batch_size = 256
    epochs = 10
    num_workers = 4
    use_gpu = True
    device = "cuda" if torch.cuda.is_available() else "cpu"
    models_dir = "/content/cs372-chess-alphaZeroLite/models"

args = Args()
print(f"Using device: {args.device}")

# Instantiate the Game and the Neural Net Wrapper
game = ChessGame()
net_wrapper = NNetWrapper(game, args)

# Load weights
weights_path = os.path.join(args.models_dir, "supervised_best.pth")
if os.path.exists(weights_path):
    print(f"Loading weights from {weights_path}...")
    folder = os.path.dirname(weights_path)
    filename = os.path.basename(weights_path)
    try:
        net_wrapper.load_checkpoint(folder=folder, filename=filename)
        print("Weights loaded successfully.")
    except Exception as e:
        print(f"Error loading weights: {e}")
else:
    print(f"Weights file not found at {weights_path}.")

# Sanity Check: Predict on the initial board
print("\n--- Sanity Check ---")
board = game.getInitBoard()
policy, value = net_wrapper.predict(board)

print(f"Prediction on initial board:")
print(f"Value (Winning probability/Score): {value}")
print(f"Policy (Move probabilities) shape: {len(policy)}")
print(f"Top 5 moves (indices): {np.argsort(policy)[-5:][::-1]}")
print(f"Top 5 probabilities: {np.sort(policy)[-5:][::-1]}")

"""**Reasoning**:
The TypeError indicates that NNetWrapper's constructor only accepts 'game', not 'args'. I will correct the instantiation to `NNetWrapper(game)` and manually set the device, maintaining the system path adjustments to avoid import errors.


"""

import sys
import os
import torch
import numpy as np

# Define paths
repo_root = '/content/cs372-chess-alphaZeroLite'
src_path = os.path.join(repo_root, 'src')

# Add the repository root and src directory to sys.path
if repo_root not in sys.path:
    sys.path.append(repo_root)
if src_path not in sys.path:
    sys.path.append(src_path)

# Import the necessary classes
from src.chess_engine.ChessGame import ChessGame
from src.chess_nnet.NNetWrapper import NNetWrapper

# Define arguments
class Args:
    batch_size = 256
    epochs = 10
    num_workers = 4
    use_gpu = True
    device = "cuda" if torch.cuda.is_available() else "cpu"
    models_dir = "/content/cs372-chess-alphaZeroLite/models"

args = Args()
print(f"Using device: {args.device}")

# Instantiate the Game
game = ChessGame()

# Instantiate the Neural Net Wrapper
# Fix: Pass only game to constructor based on the TypeError
net_wrapper = NNetWrapper(game)

# Set device manually as seen in train_supervised in main.py
net_wrapper.device = args.device
if hasattr(net_wrapper, 'nnet'):
    net_wrapper.nnet.to(args.device)

# Load weights
weights_path = os.path.join(args.models_dir, "supervised_best.pth")
if os.path.exists(weights_path):
    print(f"Loading weights from {weights_path}...")
    folder = os.path.dirname(weights_path)
    filename = os.path.basename(weights_path)
    try:
        net_wrapper.load_checkpoint(folder=folder, filename=filename)
        print("Weights loaded successfully.")
    except Exception as e:
        print(f"Error loading weights: {e}")
else:
    print(f"Weights file not found at {weights_path}.")

# Sanity Check: Predict on the initial board
print("\n--- Sanity Check ---")
board = game.getInitBoard()
policy, value = net_wrapper.predict(board)

print(f"Prediction on initial board:")
print(f"Value (Winning probability/Score): {value}")
print(f"Policy (Move probabilities) shape: {len(policy)}")
# Ensure policy is numpy array for sorting
policy_np = np.array(policy)
print(f"Top 5 moves (indices): {np.argsort(policy_np)[-5:][::-1]}")
print(f"Top 5 probabilities: {np.sort(policy_np)[-5:][::-1]}")

"""### Sanity Check Analysis

**1. Value Prediction:**
- The predicted values are consistent around `0.016`. In AlphaZero-style networks (typically using `tanh` for value), a range of `[-1, 1]` is expected. A value near `0` indicates the model views the position as "drawish" or uncertain. The consistency across random states suggests a potential bias or lack of discrimination between favorable and unfavorable positions.

**2. Policy (Move) Prediction:**
- **Low Confidence:** The top probabilities are very low (`~0.0004`). With `~4672` possible actions, a purely random choice would be `1/4672 â‰ˆ 0.00021`. The model's predictions are only slightly better than random noise, indicating it is not confident.
- **Repetitive Moves:** The top move indices (`129`, `4145`) appear in the top 5 for all simulated samples. This implies the model is outputting a static "average" policy (a prior) rather than reacting dynamically to the specific board configuration.

**Conclusion:** While the model loads and runs successfully, these metrics suggest the weights might be from an early stage of training or the model hasn't yet learned to generalize effectively.
"""

import sys
import os
import torch
import numpy as np
from torch.utils.data import Dataset, DataLoader

# 1. Setup Environment & Paths
repo_root = '/content/cs372-chess-alphaZeroLite'
src_path = os.path.join(repo_root, 'src')

# Verify paths exist
if not os.path.exists(repo_root):
    print(f"CRITICAL: {repo_root} does not exist!")
else:
    # Force insert to beginning of sys.path to ensure precedence
    if repo_root not in sys.path:
        sys.path.insert(0, repo_root)

if not os.path.exists(src_path):
    print(f"CRITICAL: {src_path} does not exist!")
else:
    if src_path not in sys.path:
        sys.path.insert(0, src_path)

print(f"sys.path configured. Repo root: {repo_root}")

# 2. Imports
try:
    # Try importing as package first
    from src.chess_engine.ChessGame import ChessGame
    from src.chess_nnet.NNetWrapper import NNetWrapper
    print("Imports successful via 'src' package.")
except ImportError:
    try:
        # Fallback: Try importing directly if src is in path root
        from chess_engine.ChessGame import ChessGame
        from chess_nnet.NNetWrapper import NNetWrapper
        print("Imports successful via direct modules.")
    except ImportError as e:
        print(f"Import Error: {e}. Please ensure dependencies are installed and paths are correct.")
        raise

# 3. Configuration
class Args:
    batch_size = 256
    use_gpu = True
    device = "cuda" if torch.cuda.is_available() else "cpu"
    models_dir = "/content/cs372-chess-alphaZeroLite/models"

args = Args()
print(f"Using device: {args.device}")

# 4. Dataset Definition
class ChessMoveDataset(Dataset):
    def __init__(self, npz_path: str):
        data = np.load(npz_path)
        self.X = data["X"]
        self.y = data["y"]
    def __len__(self):
        return self.X.shape[0]
    def __getitem__(self, idx):
        return torch.from_numpy(self.X[idx]), int(self.y[idx])

# 5. Model Instantiation & Weight Loading
def load_model(args):
    try:
        game = ChessGame()
        net_wrapper = NNetWrapper(game)
        net_wrapper.nnet.to(args.device)
    except Exception as e:
        print(f"Error instantiating model: {e}")
        return None

    weights_path = os.path.join(args.models_dir, "supervised_best.pth")
    if os.path.exists(weights_path):
        print(f"Loading weights from {weights_path}...")
        try:
            # Manual load with weights_only=False to allow pickled objects
            checkpoint = torch.load(weights_path, map_location=args.device, weights_only=False)
            if 'state_dict' in checkpoint:
                net_wrapper.nnet.load_state_dict(checkpoint['state_dict'])
            else:
                net_wrapper.nnet.load_state_dict(checkpoint)
            print("Weights loaded successfully.")
            return net_wrapper
        except Exception as e:
            print(f"Failed to load weights: {e}")
            return None
    else:
        print(f"Weights file not found at {weights_path}")
        return None

# 6. Evaluation Function
def run_evaluation():
    net_wrapper = load_model(args)
    if net_wrapper is None:
        return

    test_npz = os.path.join(repo_root, "data/processed/supervised_test.npz")
    if not os.path.exists(test_npz):
        print(f"Test dataset not found at {test_npz}. Cannot calculate quantitative accuracy.")
        return

    print(f"Evaluating on {test_npz}...")
    net_wrapper.nnet.eval()

    test_ds = ChessMoveDataset(test_npz)
    test_loader = DataLoader(test_ds, batch_size=args.batch_size, shuffle=False)

    correct_top1 = 0
    correct_top3 = 0
    total = 0

    with torch.no_grad():
        for X, y in test_loader:
            X = X.to(args.device, dtype=torch.float32)
            y = y.to(args.device, dtype=torch.long)

            logits, _ = net_wrapper.nnet(X)
            probs = torch.softmax(logits, dim=-1)

            # Top-1
            preds = probs.argmax(dim=-1)
            correct_top1 += (preds == y).sum().item()

            # Top-3
            _, topk_idx = probs.topk(3, dim=-1)
            # Check if target y is in the top 3 predictions
            matches = (topk_idx == y.unsqueeze(-1))
            correct_top3 += matches.any(dim=-1).sum().item()

            total += X.size(0)

    print(f"\n--- Evaluation Results ---")
    print(f"Total Test Examples: {total}")
    print(f"Top-1 Accuracy: {correct_top1/total:.4f} ({correct_top1}/{total})")
    print(f"Top-3 Accuracy: {correct_top3/total:.4f} ({correct_top3}/{total})")

if __name__ == "__main__":
    run_evaluation()

"""**Reasoning**:
The previous attempt to load weights failed due to pickle security restrictions (weights_only=True default). I will perform a manual load using torch.load with weights_only=False to bypass this, as we trust the repository resources. Then I will run the prediction sanity check again.


"""

import sys
import os
import torch
import numpy as np

# Ensure src is in path
repo_root = '/content/cs372-chess-alphaZeroLite'
src_path = os.path.join(repo_root, 'src')
if repo_root not in sys.path:
    sys.path.append(repo_root)
if src_path not in sys.path:
    sys.path.append(src_path)

from src.chess_engine.ChessGame import ChessGame
from src.chess_nnet.NNetWrapper import NNetWrapper

# Re-define Args for device context
class Args:
    use_gpu = True
    device = "cuda" if torch.cuda.is_available() else "cpu"
    models_dir = "/content/cs372-chess-alphaZeroLite/models"

args = Args()
print(f"Using device: {args.device}")

# Instantiate
game = ChessGame()
net_wrapper = NNetWrapper(game)
net_wrapper.nnet.to(args.device)

# Manual Weight Loading
weights_path = os.path.join(args.models_dir, "supervised_best.pth")
if os.path.exists(weights_path):
    print(f"Attempting manual load from {weights_path}...")
    try:
        # Load with weights_only=False to allow the pickled Args object
        checkpoint = torch.load(weights_path, map_location=args.device, weights_only=False)

        # Load state_dict
        if 'state_dict' in checkpoint:
            net_wrapper.nnet.load_state_dict(checkpoint['state_dict'])
        else:
            net_wrapper.nnet.load_state_dict(checkpoint)

        print("Weights loaded successfully!")
    except Exception as e:
        print(f"Manual load failed: {e}")
else:
    print(f"Weights file not found at {weights_path}")

# Sanity Check
print("\n--- Sanity Check Results ---")
board = game.getInitBoard()
policy, value = net_wrapper.predict(board)

print(f"Value Prediction (Win Prob): {value}")
# Top moves
policy_np = np.array(policy)
top_indices = np.argsort(policy_np)[-5:][::-1]
top_probs = np.sort(policy_np)[-5:][::-1]

print(f"Top 5 Move Indices: {top_indices}")
print(f"Top 5 Move Probs:   {top_probs}")

"""## Run Sanity Check

### Subtask:
Test the loaded model by predicting moves for a few sample board states generated via simulation.

**Reasoning**:
Generate 3 sample board states by simulating random moves and use the model to predict the policy and value for each state to verify model behavior.
"""

import numpy as np
import random

print("--- Sanity Check on Simulated States ---")

# Generate 3 sample board states
for i in range(3):
    print(f"\nSample {i+1}:")

    # Initialize board and player
    board = game.getInitBoard()
    cur_player = 1

    # Simulate 5 to 15 random moves
    num_moves = random.randint(5, 15)
    print(f"Simulating {num_moves} random moves...")

    for _ in range(num_moves):
        # Get valid moves (returns a binary vector of size ACTION_SIZE)
        valid_moves = game.getValidMoves(board, cur_player)
        # Get indices of valid moves where the value is 1
        valid_indices = np.where(valid_moves == 1)[0]

        if len(valid_indices) == 0:
            print("Game ended early (no valid moves).")
            break

        # Select a random valid action
        action = np.random.choice(valid_indices)

        # Update board and player
        board, cur_player = game.getNextState(board, cur_player, action)

    # Get canonical form for the current player to feed into the network
    canonical_board = game.getCanonicalForm(board, cur_player)

    # Predict
    policy, value = net_wrapper.predict(canonical_board)

    # Output results
    print(f"Value (Win Probability/Score): {value:.4f}")

    # Process policy to find top 5 moves
    policy_np = np.array(policy)
    # Mask invalid moves to focus on valid predictions (optional but good for context)
    # For raw network output check, we just look at the highest logits/probs regardless of validity,
    # but typically we only care about valid moves. The instruction asks for Top 5 Policy moves.
    # Let's show the raw top 5 from the network output.

    top_indices = np.argsort(policy_np)[-5:][::-1]
    top_probs = np.sort(policy_np)[-5:][::-1]

    print(f"Top 5 Move Indices: {top_indices}")
    print(f"Top 5 Probabilities: {top_probs}")

"""## Fix and Run Evaluation

### Subtask:
Define the dataset class and evaluate the model's accuracy on the test set.

## Summary:

### Q&A

*   **How is the model evaluated on the test set?**
    The model is evaluated by defining a `ChessMoveDataset` class to load data from `supervised_test.npz`. The `net_wrapper` is then used to predict moves, comparing them against the ground truth to calculate Top-1 and Top-3 accuracy.

### Data Analysis Key Findings

*   **Dataset Class Implementation:** A custom `ChessMoveDataset` class was defined to interface with the `.npz` file format, ensuring proper loading of chess board features and move labels for testing.
*   **Metric Definition:** The evaluation logic was established to compute two key performance indicators:
    *   **Top-1 Accuracy:** Measures exact matches between the model's highest confidence prediction and the actual move.
    *   **Top-3 Accuracy:** Measures whether the correct move falls within the model's top three highest confidence predictions.
*   **Robustness:** The process includes error handling to manage scenarios where the dataset file might be missing from the specified path.

### Insights or Next Steps

*   **Performance Benchmarking:** Upon execution, compare the Top-1 and Top-3 gaps; a large gap suggests the model often considers the correct move as a strong candidate even if it misses the exact top spot.
*   **Failure Analysis:** If accuracy is lower than expected, isolate specific board states where the correct move is not in the Top-3 to understand if the model struggles with specific tactical motifs or endgame scenarios.
"""